
'''Info Header Start
Name : extLogger
Author : Wieland@AMB-ZEPH15
Saveorigin : Project.toe
Saveversion : 2023.12000
Info Header End'''
import datetime
import os
import inspect
from pathlib import Path
import json
import logging
import sqlite3
from functools import cached_property


class callTimer(object):
	def __init__(self, name):
		self.start = datetime.datetime.now()
		self.name = name
	def __enter__(self):
		return self.name
	def __exit__(self, type, value, traceback):
		op("timing").appendRow((
			self.name,
			(datetime.datetime.now() - self.start)
		))

class extLogger:

	def __init__(self, ownerComp):
		# The component to which this extension is attached
		self.ownerComp = ownerComp
		
	def get_stack_element(self, stack):
		try:
			return stack.pop( self.ownerComp.par.Traceoffset.eval() )
		except:
			return ''

	def format_stack_element(self, stack_element):
		if not stack_element: return "NA"
		return f"{stack_element.filename}.{stack_element.function}:{stack_element.lineno}"

	def Log(self, *messages, level = "INFO"):
		stack = inspect.stack()
		
		debugged_stack = self.get_stack_element(stack)
		caller_stack =  self.get_stack_element(stack)

		_messages = ( 
			json.dumps( message ) if isinstance( message, (dict, list, tuple)) else message 
			for message in messages 
		)
		dataset = {
			"level" : level,
			"timestamp" : datetime.datetime.now().isoformat(),
			"debugged" : self.format_stack_element( debugged_stack ),
			"caller" : self.format_stack_element( caller_stack ),
			"messages" : tuple( _messages )
		}
		
		if self.ownerComp.par.Textport.eval(): 
			with callTimer("textport"):
				self.to_Textport( dataset )
				
		if self.ownerComp.par.Textfileoutput.eval(): 
			with callTimer("Textfile"):
				self.to_Text_File( dataset )

		if self.ownerComp.par.Jsonfileoutput.eval():
			with callTimer("JSON File"):
				self.to_Json_File( dataset )
			
		if self.ownerComp.par.Sqliteoutput.eval():
			with callTimer("Database"):
				self.to_Database( dataset )
			
		self.ownerComp.op('fifo1').appendRow( tuple(dataset.values()) )
		return

	def to_Textport(self, dataset):
		# LoggerExt.Log(message: str, level: str, withInfos: bool = True, **logItemDict: dict) -> None
		self.ownerComp.par.Logger.eval().Log(
			json.dumps({
				"source" : f"{self.ownerComp.par.Logname.eval()}:{self.ownerComp.path}",
				**dataset
				}, indent=1),
			level = dataset["level"],
			withInfos = False
		)
	
		return
	
	def path_join(self, *args):
		return "/".join([arg.strip("/").strip("\\") for arg in args])

	def timestamp(self):
		return datetime.datetime.utcnow().strftime("%Y-%m-%d") * self.ownerComp.par.Timestampedfile.eval() 

	@property
	def textfilePath(self):
		return self.path_join(
			self.ownerComp.par.Folder.eval(),
			f"{self.timestamp()}{self.ownerComp.par.Logname.eval()}.log"
		)

	def to_Text_File(self, dataset):
		debug_string = self.ownerComp.path
		for element in dataset.values():
			debug_string += f"{element}\t"
		debug_string += '\n'
		os.makedirs( self.ownerComp.par.Folder.eval(), exist_ok=True)
		with open( self.textfilePath, "at") as logfile:
			logfile.write( debug_string )
	
	def to_Json_File(self, dataset):
		jsonFileObject = Path(
			self.ownerComp.par.Folder.eval(), 
			f"{self.timestamp()}{self.ownerComp.par.Logname.eval()}"
		).with_suffix(".json")

		if not jsonFileObject.is_file():
			jsonFileObject.parent.mkdir( exist_ok=True, parents=True)
			jsonFileObject.touch(exist_ok=True)
			jsonFileObject.write_text('[{"NOTE":"DO NOT EDIT THIS FILE BY HAND! MACHINE WRITTEN AND HANDLED!"}]')
		
		with jsonFileObject.open("r+b") as jsonFileWriter:
			jsonFileWriter.seek(-1, 2)
			jsonFileWriter.write(",".encode(encoding="ascii"))
			jsonFileWriter.write(json.dumps(dataset,ensure_ascii=True).encode(encoding="ascii"))
			jsonFileWriter.write(b"]")
		return
	
	@cached_property
	def _sqliteCursor(self):
		with callTimer("Get Cursor"):
			return self.ownerComp.op("adapterDependency").GetGlobalComponent().GetCursor(
				self.ownerComp.par.Sqlitedatabase.eval(),
				logs = (
						"source TINYTEXT",
						"level TINYTEXT",
						"timestamp DATE",
						"caller TINYTEXT",
						"debugged_element TINYTEXT",
						"messages TEXT"
				)
			)

	def to_Database(self, dataset):
		with callTimer("Fetching Cursor"):
			cursor:sqlite3.Cursor = self._sqliteCursor
		
		with callTimer("Execute Insert"):
			cursor.execute("INSERT INTO logs VALUES(?,?,?,?,?,?)", 
					( 	self.ownerComp.par.Logname.eval(), 
						dataset["level"], 
						dataset["timestamp"], 
						dataset["caller"], 
						dataset["debugged"], 
						"\n".join(dataset["messages"]) )
			)
		with callTimer("Comitting"):
			self.ownerComp.op("adapterDependency").GetGlobalComponent().Commit( cursor )
		return